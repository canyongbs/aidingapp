# File generated by "php artisan lighthouse:ide-helper".
# Do not edit this file directly.
# This file should be ignored by git as it can be autogenerated.

enum AlertSeverity {
  Low
  Medium
  High
}

enum AlertStatus {
  Active
  Resolved
  Canceled
}

enum ContactStatusColorOptions {
  Success
  Danger
  Warning
  Info
  Primary
  Gray
}

enum SystemContactClassification {
  New
  Assigned
  InProgress
  Converted
  Recycled
  NotInterested
  Custom
}

"""
The `String` scalar type represents textual data, represented as UTF-8
character sequences. The String type is most often used by GraphQL to
represent free-form human-readable text.
"""
scalar String

"""
The `Int` scalar type represents non-fractional signed whole numeric
values. Int can represent values between -(2^31) and 2^31 - 1. 
"""
scalar Int

"The `Boolean` scalar type represents `true` or `false`."
scalar Boolean

type Alert {
  "Unique primary key."
  id: UUID!

  "The Concern of the alert."
  concern: Educatable!

  "The description of the alert."
  description: String!

  "The severity of the alert."
  severity: AlertSeverity!

  "The status of the alert."
  status: AlertStatus!

  "The suggested intervention for the alert."
  suggested_intervention: String!

  "The created datetime of the alert."
  created_at: DateTime

  "The updated datetime of the alert."
  updated_at: DateTime

  "The deleted datetime of the alert."
  deleted_at: DateTime
}

input AlertConcernsQuery {
  contact: ContactsQuery
}

input AlertsQuery {
  id: UUID
  concern: AlertConcernsQuery
  concern_id: EducatableId
  concern_type: EducatableType
  description: String
  severity: AlertSeverity
  status: AlertStatus
  suggested_intervention: String
  created_at: DateTime
  updated_at: DateTime
  deleted_at: DateTime
}

type AlertQueries {
  "Find a single alert by an identifying attribute."
  find(
    "The value of the attribute to match."
    id: UUID!

    "Allows to filter if trashed elements should be fetched."
    trashed: Trashed
  ): Alert

  "List multiple alerts."
  list(
    where: SearchByRootAlertsQuery

    "Limits number of fetched items. Maximum allowed value: 100."
    first: Int! = 25

    "The offset from which items are returned."
    page: Int

    "Allows to filter if trashed elements should be fetched."
    trashed: Trashed
  ): AlertPaginator!
}

input CreateAlertInput {
  "The Concern related to the alert."
  concern_id: EducatableId!

  "The type of Concern related to the alert."
  concern_type: EducatableType!

  "The description of the alert."
  description: String!

  "The severity of the alert."
  severity: AlertSeverity!

  "The status of the alert."
  status: AlertStatus!

  "The suggested intervention for the alert."
  suggested_intervention: String!
}

input UpdateAlertInput {
  "The description of the alert."
  description: String

  "The severity of the alert."
  severity: AlertSeverity

  "The status of the alert."
  status: AlertStatus

  "The suggested intervention for the alert."
  suggested_intervention: String
}

type AlertMutations {
  "Create an alert."
  create(input: CreateAlertInput!): Alert!

  "Update an alert."
  update(
    "The identifier of the alert you would like to update."
    id: UUID!

    "The fields you would like to update."
    input: UpdateAlertInput!
  ): Alert!

  "Delete an alert."
  delete(
    "The identifier of the alert you would like to delete."
    id: UUID!
  ): Alert
}

union Auditable = Contact | User | SystemUser

input AuditableablesQuery {
  contact: ContactsQuery
  user: UsersQuery
  system_user: SystemUsersQuery
}

type Audit {
  "Unique primary key."
  id: UUID!

  change_agent_type: String
  change_agent_id: UUID
  event: String!
  old_values: JSON
  new_values: JSON
  url: String
  ip_address: String
  user_agent: String
  tags: String
  created_at: DateTime
  updated_at: DateTime
  auditable: Auditable
  user: Authenticatable
}

input AuthenticatablesQuery {
  user: UsersQuery
  system_user: SystemUsersQuery
}

input AuditsQuery {
  id: UUID
  change_agent_type: String
  change_agent_id: UUID
  event: String
  old_values: JSON
  new_values: JSON
  url: String
  ip_address: String
  user_agent: String
  tags: String
  created_at: DateTime
  updated_at: DateTime
  auditable: AuditableablesQuery
  user: AuthenticatablesQuery
}

type AuditQueries {
  find(id: UUID!): Audit
  list(
    where: SearchByRootAuditsQuery
    order: [SortByRootAuditsQuery!]

    "Limits number of fetched items. Maximum allowed value: 100."
    first: Int! = 25

    "The offset from which items are returned."
    page: Int
  ): AuditPaginator!
}

type ContactSource {
  "Unique primary key."
  id: UUID!

  "The name of the contact source."
  name: String!

  "The created date of the contact source."
  created_at: DateTime

  "The updated date of the contact source."
  updated_at: DateTime

  "The deleted date of the contact source."
  deleted_at: DateTime

  "Contacts related to this contact source."
  contacts: [Contact!]

  "The count of contacts related to this contact source."
  contacts_count: Int

  "The audits related to this contact source."
  audits: [Audit!]

  "The count of audits related to this contact source."
  audits_count: Int
}

input ContactSourcesQuery {
  "The unique primary key of the contact source."
  id: UUID

  "The name of the contact source."
  name: String

  "The created date of the contact source."
  created_at: DateTime

  "The updated date of the contact source."
  updated_at: DateTime

  "The deleted date of the contact source."
  deleted_at: DateTime

  "The contacts related to this contact source."
  contacts: ContactsQuery

  "The audits related to this contact source."
  audits: AuditsQuery
}

type ContactSourceQueries {
  "Get a specific contact source by ID."
  find(
    id: UUID!

    "Allows to filter if trashed elements should be fetched."
    trashed: Trashed
  ): ContactSource

  "List multiple contact sources."
  list(
    "Filter by the contact sources attributes and relations."
    where: SearchByRootContactSourcesQuery

    order: [SortByRootContactSourcesQuery!]

    "Limits number of fetched items. Maximum allowed value: 100."
    first: Int! = 25

    "The offset from which items are returned."
    page: Int

    "Allows to filter if trashed elements should be fetched."
    trashed: Trashed
  ): ContactSourcePaginator!
}

input CreateContactSourceInput {
  "The name of the contact source."
  name: String!
}

input UpdateContactSourceInput {
  "The name of the contact source."
  name: String
}

type ContactSourceMutations {
  "Create an contact source."
  create(input: CreateContactSourceInput!): ContactSource!

  "Update an existing contact source."
  update(
    "The identifier of the contact source you would like to update."
    id: UUID!

    "The fields you would like to update."
    input: UpdateContactSourceInput!
  ): ContactSource!

  "Delete an existing contact source."
  delete(
    "The identifier of the contact source you would like to delete."
    id: UUID!
  ): ContactSource
}

type ContactStatus {
  "Unique primary key."
  id: UUID!

  "The name of the contact status."
  name: String!

  "The classification of the contact status."
  classification: SystemContactClassification!

  "The color of the contact status."
  color: ContactStatusColorOptions!

  "The created date of the contact status."
  created_at: DateTime

  "The updated date of the contact status."
  updated_at: DateTime

  "The deleted date of the contact status."
  deleted_at: DateTime

  "Contacts related to this contact status."
  contacts: [Contact!]

  "The count of contacts related to this contact status."
  contacts_count: Int

  "The audits related to this contact status."
  audits: [Audit!]

  "The count of audits related to this contact status."
  audits_count: Int
}

input ContactStatusesQuery {
  "The unique primary key of the contact status."
  id: UUID

  "The name of the contact status."
  name: String

  "The classification of the contact status."
  classification: SystemContactClassification

  "The color of the contact status."
  color: ContactStatusColorOptions

  "The created date of the contact status."
  created_at: DateTime

  "The updated date of the contact status."
  updated_at: DateTime

  "The deleted date of the contact status."
  deleted_at: DateTime

  "The contacts related to this contact status."
  contacts: ContactsQuery

  "The audits related to this contact status."
  audits: AuditsQuery
}

type ContactStatusQueries {
  "Get a specific contact status by ID."
  find(
    id: UUID!

    "Allows to filter if trashed elements should be fetched."
    trashed: Trashed
  ): ContactStatus

  "List multiple contacts statuses."
  list(
    "Filter by the contact statuses attributes and relations."
    where: SearchByRootContactStatusesQuery

    order: [SortByRootContactStatusesQuery!]

    "Limits number of fetched items. Maximum allowed value: 100."
    first: Int! = 25

    "The offset from which items are returned."
    page: Int

    "Allows to filter if trashed elements should be fetched."
    trashed: Trashed
  ): ContactStatusPaginator!
}

input CreateContactStatusInput {
  "The name of the contact status."
  name: String!

  "The classification of the contact status."
  classification: SystemContactClassification!

  "The color of the contact status."
  color: ContactStatusColorOptions!
}

input UpdateContactStatusInput {
  "The name of the contact status."
  name: String

  "The classification of the contact status."
  classification: SystemContactClassification

  "The color of the contact status."
  color: ContactStatusColorOptions
}

type ContactStatusMutations {
  "Create an contact status."
  create(input: CreateContactStatusInput!): ContactStatus!

  "Update an existing contact status."
  update(
    "The identifier of the contact status you would like to update."
    id: UUID!

    "The fields you would like to update."
    input: UpdateContactStatusInput!
  ): ContactStatus!

  "Delete an existing contact status."
  delete(
    "The identifier of the contact status you would like to delete."
    id: UUID!
  ): ContactStatus
}

type Contact {
  "Unique primary key."
  id: UUID!

  "The status of the contact."
  status: ContactStatus!

  "The source of the contact."
  source: ContactSource!

  "The first name of the contact."
  first_name: String!

  "The last name of the contact."
  last_name: String!

  "The full name of the contact."
  full_name: String!

  "The preferred name of the contact."
  preferred: String

  "The display name of the contact."
  display_name: String

  "The description of the contact."
  description: String

  "The email of the contact."
  email: Email

  "The mobile number of the contact."
  mobile: String

  "The phone number of the contact."
  phone: String

  "If the contact is opted out of SMS messages."
  sms_opt_out: Boolean

  "If the contact's email bounces."
  email_bounce: Boolean

  "The address of the contact."
  address: String

  "The address 2 of the contact."
  address_2: String

  "The address 3 of the contact."
  address_3: String

  "The city of the contact."
  city: String

  "The state of the contact."
  state: String

  "The postal code of the contact."
  postal: String

  "The created date of the contact."
  created_at: DateTime

  "The updated date of the contact."
  updated_at: DateTime

  "The deleted date of the contact."
  deleted_at: DateTime

  audits: [Audit!]
  audits_count: Int
  created_by: User
  assigned_to: User
}

input ContactsQuery {
  "Unique primary key."
  id: UUID

  "The status ID of the contact."
  status_id: UUID

  "The status of the contact."
  status: ContactStatusesQuery

  "The source ID of the contact."
  source_id: UUID

  "The source of the contact."
  source: ContactSourcesQuery

  "The first name of the contact."
  first_name: String

  "The last name of the contact."
  last_name: String

  "The full name of the contact."
  full_name: String

  "The preferred name of the contact."
  preferred: String

  "The description of the contact."
  description: String

  "The email of the contact."
  email: Email

  "The mobile number of the contact."
  mobile: String

  "The phone number of the contact."
  phone: String

  "If the contact is opted out of SMS messages."
  sms_opt_out: Boolean

  "If the contact's email bounces."
  email_bounce: Boolean

  "The address of the contact."
  address: String

  "The address 2 of the contact."
  address_2: String

  "The address 3 of the contact."
  address_3: String

  "The city of the contact."
  city: String

  "The state of the contact."
  state: String

  "The postal code of the contact."
  postal: String

  "The created date of the contact."
  created_at: DateTime

  "The updated date of the contact."
  updated_at: DateTime

  "The deleted date of the contact."
  deleted_at: DateTime
  audits: AuditsQuery
  created_by: UsersQuery
  assigned_to: UsersQuery
}

type ContactQueries {
  "Find a single contact by an identifying attribute."
  find(
    "The value of the attribute to match."
    id: UUID!
  ): Contact

  "List multiple contacts."
  list(
    where: SearchByRootContactsQuery
    order: [SortByRootContactsQuery!]

    "Limits number of fetched items. Maximum allowed value: 100."
    first: Int! = 25

    "The offset from which items are returned."
    page: Int
  ): ContactPaginator!
}

input CreateContactInput {
  "The status of the contact."
  status_id: UUID!

  "The source of the contact."
  source_id: UUID!

  "The first name of the contact."
  first_name: String!

  "The last name of the contact."
  last_name: String!

  "The full name of the contact."
  full_name: String!

  "The preferred name of the contact."
  preferred: String

  "The description of the contact."
  description: String

  "The email of the contact."
  email: Email

  "The mobile number of the contact."
  mobile: String

  "The phone number of the contact."
  phone: String

  "If the contact is opted out of SMS messages."
  sms_opt_out: Boolean

  "If the contact's email bounces."
  email_bounce: Boolean

  "The address of the contact."
  address: String

  "The address 2 of the contact."
  address_2: String

  "The address 3 of the contact."
  address_3: String

  "The city of the contact."
  city: String

  "The state of the contact."
  state: String

  "The postal code of the contact."
  postal: String

  "The user that created the contact."
  created_by_id: UUID

  "The user the contact is assigned to."
  assigned_to_id: UUID
}

input UpdateContactInput {
  "The status of the contact."
  status_id: UUID

  "The source of the contact."
  source_id: UUID

  "The first name of the contact."
  first_name: String

  "The last name of the contact."
  last_name: String

  "The full name of the contact."
  full_name: String

  "The preferred name of the contact."
  preferred: String

  "The description of the contact."
  description: String

  "The email of the contact."
  email: Email

  "The mobile number of the contact."
  mobile: String

  "The phone number of the contact."
  phone: String

  "If the contact is opted out of SMS messages."
  sms_opt_out: Boolean

  "If the contact's email bounces."
  email_bounce: Boolean

  "The address of the contact."
  address: String

  "The address 2 of the contact."
  address_2: String

  "The address 3 of the contact."
  address_3: String

  "The city of the contact."
  city: String

  "The state of the contact."
  state: String

  "The postal code of the contact."
  postal: String

  "The user that created the contact."
  created_by_id: UUID

  "The user the contact is assigned to."
  assigned_to_id: UUID
}

type ContactMutations {
  "Create an contact."
  create(input: CreateContactInput!): Contact!

  "Update an contact."
  update(
    "The identifier of the contact you would like to update."
    id: UUID!

    "The fields you would like to update."
    input: UpdateContactInput!
  ): Contact!

  "Delete an contact."
  delete(
    "The identifier of the contact you would like to delete."
    id: UUID!
  ): Contact
}

type Division {
  "Unique primary key."
  id: UUID!

  "The name of the division."
  name: String!
}

input DivisionQuery {
  "The name of the division."
  name: String
}

type UserSubscription {
  "Unique primary key."
  id: UUID!

  "The User related to this subscription."
  user: User!

  "The Subscribable the User is subscribed to."
  subscribable: Educatable!

  "The created date of the subscription."
  created_at: DateTime

  "The updated date of the subscription."
  updated_at: DateTime
}

input UserSubscriptionSubscribablesQuery {
  contact: ContactsQuery
}

input SubscriptionsQuery {
  id: UUID
  user: UsersQuery
  subscribable: UserSubscriptionSubscribablesQuery
  subscribable_id: EducatableId
  subscribable_type: EducatableType
  created_at: DateTime
  updated_at: DateTime
}

type UserSubscriptionQueries {
  "Find a single subscription by an identifying attribute."
  find(
    "The value of the attribute to match."
    id: UUID!
  ): UserSubscription

  "List multiple subscriptions."
  list(
    where: SearchByRootSubscriptionsQuery

    "Limits number of fetched items. Maximum allowed value: 100."
    first: Int! = 25

    "The offset from which items are returned."
    page: Int
  ): UserSubscriptionPaginator!
}

input CreateUserSubscriptionInput {
  "The user to subscribe."
  user_id: UUID!

  "The subscribable to subscribe to."
  subscribable_id: EducatableId!

  "The type of subscribable to subscribe to."
  subscribable_type: EducatableType!
}

type UserSubscriptionMutations {
  "Subscribe a User to a Subscribable."
  subscribe(input: CreateUserSubscriptionInput!): UserSubscription!

  "Unsubscribe a User from a Subscribable."
  unsubscribe(
    "The primary key of the subscription."
    id: UUID!
  ): UserSubscription
}

type ServiceRequest {
  "Unique primary key."
  id: UUID!
}

input ServiceRequestQuery {
  "Unique primary key."
  id: UUID
}

type ServiceRequestAssignment {
  "Unique primary key."
  id: UUID!

  "The service request of the assignment."
  service_request: ServiceRequest

  "The user of the assignment."
  user: User

  "The created datetime of the assignment."
  created_at: DateTime

  "The updated datetime of the assignment."
  updated_at: DateTime
}

"Information about pagination using a fully featured paginator."
type PaginatorInfo {
  "Number of items in the current page."
  count: Int!

  "Index of the current page."
  currentPage: Int!

  "Index of the first item in the current page."
  firstItem: Int

  "Are there more pages after this one?"
  hasMorePages: Boolean!

  "Index of the last item in the current page."
  lastItem: Int

  "Index of the last available page."
  lastPage: Int!

  "Number of items per page."
  perPage: Int!

  "Number of total available items."
  total: Int!
}

"A paginated list of User items."
type UserPaginator {
  "Pagination information about the list of items."
  paginatorInfo: PaginatorInfo!

  "A list of User items."
  data: [User!]!
}

"A paginated list of SystemUser items."
type SystemUserPaginator {
  "Pagination information about the list of items."
  paginatorInfo: PaginatorInfo!

  "A list of SystemUser items."
  data: [SystemUser!]!
}

"A paginated list of Alert items."
type AlertPaginator {
  "Pagination information about the list of items."
  paginatorInfo: PaginatorInfo!

  "A list of Alert items."
  data: [Alert!]!
}

"A paginated list of Audit items."
type AuditPaginator {
  "Pagination information about the list of items."
  paginatorInfo: PaginatorInfo!

  "A list of Audit items."
  data: [Audit!]!
}

"A paginated list of ContactSource items."
type ContactSourcePaginator {
  "Pagination information about the list of items."
  paginatorInfo: PaginatorInfo!

  "A list of ContactSource items."
  data: [ContactSource!]!
}

"A paginated list of ContactStatus items."
type ContactStatusPaginator {
  "Pagination information about the list of items."
  paginatorInfo: PaginatorInfo!

  "A list of ContactStatus items."
  data: [ContactStatus!]!
}

"A paginated list of Contact items."
type ContactPaginator {
  "Pagination information about the list of items."
  paginatorInfo: PaginatorInfo!

  "A list of Contact items."
  data: [Contact!]!
}

"A paginated list of UserSubscription items."
type UserSubscriptionPaginator {
  "Pagination information about the list of items."
  paginatorInfo: PaginatorInfo!

  "A list of UserSubscription items."
  data: [UserSubscription!]!
}

enum SearchByTypeFlag {
  Yes
}

"Available operators for `scalar UUID` (only one operator allowed at a time)."
input SearchByScalarUUIDOrNull {
  "Equal (`=`)."
  equal: UUID

  "Not Equal (`!=`)."
  notEqual: UUID

  "Within a set of values."
  in: [UUID!]

  "Outside a set of values."
  notIn: [UUID!]

  "Is NULL?"
  isNull: SearchByTypeFlag

  "Is NOT NULL?"
  isNotNull: SearchByTypeFlag
}

"Available operators for `scalar Email` (only one operator allowed at a time)."
input SearchByScalarEmailOrNull {
  "Equal (`=`)."
  equal: Email

  "Not Equal (`!=`)."
  notEqual: Email

  "Like."
  like: Email

  "Not like."
  notLike: Email

  "Within a set of values."
  in: [Email!]

  "Outside a set of values."
  notIn: [Email!]

  "Contains."
  contains: Email

  "Not contains."
  notContains: Email

  "Starts with a string."
  startsWith: Email

  "Not starts with a string."
  notStartsWith: Email

  "Ends with a string."
  endsWith: Email

  "Not ends with a string."
  notEndsWith: Email

  "Is NULL?"
  isNull: SearchByTypeFlag

  "Is NOT NULL?"
  isNotNull: SearchByTypeFlag
}

input SearchByTypeRangeInt {
  min: Int!
  max: Int!
}

"Available operators for `scalar Int` (only one operator allowed at a time)."
input SearchByScalarInt {
  "Equal (`=`)."
  equal: Int

  "Not Equal (`!=`)."
  notEqual: Int

  "Less than (`<`)."
  lessThan: Int

  "Less than or equal to (`<=`)."
  lessThanOrEqual: Int

  "Greater than (`>`)."
  greaterThan: Int

  "Greater than or equal to (`>=`)."
  greaterThanOrEqual: Int

  "Within a set of values."
  in: [Int!]

  "Outside a set of values."
  notIn: [Int!]

  "Within a range."
  between: SearchByTypeRangeInt

  "Outside a range."
  notBetween: SearchByTypeRangeInt

  "Bitwise OR (`|`)."
  bitwiseOr: Int

  "Bitwise XOR (`^`)."
  bitwiseXor: Int

  "Bitwise AND (`&`)."
  bitwiseAnd: Int

  "Bitwise Left shift (`<<`)."
  bitwiseLeftShift: Int

  "Bitwise Right shift (`>>`)."
  bitwiseRightShift: Int
}

"Available operators for `scalar String` (only one operator allowed at a time)."
input SearchByScalarStringOrNull {
  "Equal (`=`)."
  equal: String

  "Not Equal (`!=`)."
  notEqual: String

  "Like."
  like: String

  "Not like."
  notLike: String

  "Within a set of values."
  in: [String!]

  "Outside a set of values."
  notIn: [String!]

  "Contains."
  contains: String

  "Not contains."
  notContains: String

  "Starts with a string."
  startsWith: String

  "Not starts with a string."
  notStartsWith: String

  "Ends with a string."
  endsWith: String

  "Not ends with a string."
  notEndsWith: String

  "Is NULL?"
  isNull: SearchByTypeFlag

  "Is NOT NULL?"
  isNotNull: SearchByTypeFlag
}

"Available operators for `scalar JSON` (only one operator allowed at a time)."
input SearchByScalarJSONOrNull {
  "Equal (`=`)."
  equal: JSON

  "Not Equal (`!=`)."
  notEqual: JSON

  "Like."
  like: JSON

  "Not like."
  notLike: JSON

  "Within a set of values."
  in: [JSON!]

  "Outside a set of values."
  notIn: [JSON!]

  "Contains."
  contains: JSON

  "Not contains."
  notContains: JSON

  "Starts with a string."
  startsWith: JSON

  "Not starts with a string."
  notStartsWith: JSON

  "Ends with a string."
  endsWith: JSON

  "Not ends with a string."
  notEndsWith: JSON

  "Is NULL?"
  isNull: SearchByTypeFlag

  "Is NOT NULL?"
  isNotNull: SearchByTypeFlag
}

input SearchByTypeRangeDateTime {
  min: DateTime!
  max: DateTime!
}

"Available operators for `scalar DateTime` (only one operator allowed at a time)."
input SearchByScalarDateTimeOrNull {
  "Equal (`=`)."
  equal: DateTime

  "Not Equal (`!=`)."
  notEqual: DateTime

  "Less than (`<`)."
  lessThan: DateTime

  "Less than or equal to (`<=`)."
  lessThanOrEqual: DateTime

  "Greater than (`>`)."
  greaterThan: DateTime

  "Greater than or equal to (`>=`)."
  greaterThanOrEqual: DateTime

  "Within a set of values."
  in: [DateTime!]

  "Outside a set of values."
  notIn: [DateTime!]

  "Within a range."
  between: SearchByTypeRangeDateTime

  "Outside a range."
  notBetween: SearchByTypeRangeDateTime

  "Is NULL?"
  isNull: SearchByTypeFlag

  "Is NOT NULL?"
  isNotNull: SearchByTypeFlag
}

"Available operators for `enum SystemContactClassification` (only one operator allowed at a time)."
input SearchByEnumSystemContactClassificationOrNull {
  "Equal (`=`)."
  equal: SystemContactClassification

  "Not Equal (`!=`)."
  notEqual: SystemContactClassification

  "Within a set of values."
  in: [SystemContactClassification!]

  "Outside a set of values."
  notIn: [SystemContactClassification!]

  "Is NULL?"
  isNull: SearchByTypeFlag

  "Is NOT NULL?"
  isNotNull: SearchByTypeFlag
}

"Available operators for `enum ContactStatusColorOptions` (only one operator allowed at a time)."
input SearchByEnumContactStatusColorOptionsOrNull {
  "Equal (`=`)."
  equal: ContactStatusColorOptions

  "Not Equal (`!=`)."
  notEqual: ContactStatusColorOptions

  "Within a set of values."
  in: [ContactStatusColorOptions!]

  "Outside a set of values."
  notIn: [ContactStatusColorOptions!]

  "Is NULL?"
  isNull: SearchByTypeFlag

  "Is NOT NULL?"
  isNotNull: SearchByTypeFlag
}

"Available conditions for `input ContactStatusesQuery` (only one field allowed at a time)."
input SearchByConditionContactStatusesQuery {
  "The unique primary key of the contact status."
  id: SearchByScalarUUIDOrNull

  "The name of the contact status."
  name: SearchByScalarStringOrNull

  "The classification of the contact status."
  classification: SearchByEnumSystemContactClassificationOrNull

  "The color of the contact status."
  color: SearchByEnumContactStatusColorOptionsOrNull

  "The created date of the contact status."
  created_at: SearchByScalarDateTimeOrNull

  "The updated date of the contact status."
  updated_at: SearchByScalarDateTimeOrNull

  "The deleted date of the contact status."
  deleted_at: SearchByScalarDateTimeOrNull

  "The contacts related to this contact status."
  contacts: SearchByRelationshipContactsQuery

  "The audits related to this contact status."
  audits: SearchByRelationshipAuditsQuery
}

"Available conditions for `input ContactStatusesQuery` (only one field allowed at a time)."
input SearchByRootContactStatusesQuery {
  "Field."
  field: SearchByConditionContactStatusesQuery

  "All of the conditions must be true."
  allOf: [SearchByRootContactStatusesQuery!]

  "Any of the conditions must be true."
  anyOf: [SearchByRootContactStatusesQuery!]

  "Not."
  not: SearchByRootContactStatusesQuery
}

"""
Conditions for the relationship (`has()`/`doesntHave()`) for `input ContactStatusesQuery`.

See also:
* https://laravel.com/docs/eloquent-relationships#querying-relationship-existence
* https://laravel.com/docs/eloquent-relationships#querying-relationship-absence
"""
input SearchByRelationshipContactStatusesQuery {
  "Additional conditions."
  where: SearchByRootContactStatusesQuery

  "Count conditions."
  count: SearchByScalarInt

  "Alias for `count: {greaterThanOrEqual: 1}`. Will be ignored if `count` used."
  exists: Boolean

  "Alias for `count: {lessThan: 1}`. Will be ignored if `count` used."
  notExists: Boolean! = false
}

"Available conditions for `input ContactSourcesQuery` (only one field allowed at a time)."
input SearchByConditionContactSourcesQuery {
  "The unique primary key of the contact source."
  id: SearchByScalarUUIDOrNull

  "The name of the contact source."
  name: SearchByScalarStringOrNull

  "The created date of the contact source."
  created_at: SearchByScalarDateTimeOrNull

  "The updated date of the contact source."
  updated_at: SearchByScalarDateTimeOrNull

  "The deleted date of the contact source."
  deleted_at: SearchByScalarDateTimeOrNull

  "The contacts related to this contact source."
  contacts: SearchByRelationshipContactsQuery

  "The audits related to this contact source."
  audits: SearchByRelationshipAuditsQuery
}

"Available conditions for `input ContactSourcesQuery` (only one field allowed at a time)."
input SearchByRootContactSourcesQuery {
  "Field."
  field: SearchByConditionContactSourcesQuery

  "All of the conditions must be true."
  allOf: [SearchByRootContactSourcesQuery!]

  "Any of the conditions must be true."
  anyOf: [SearchByRootContactSourcesQuery!]

  "Not."
  not: SearchByRootContactSourcesQuery
}

"""
Conditions for the relationship (`has()`/`doesntHave()`) for `input ContactSourcesQuery`.

See also:
* https://laravel.com/docs/eloquent-relationships#querying-relationship-existence
* https://laravel.com/docs/eloquent-relationships#querying-relationship-absence
"""
input SearchByRelationshipContactSourcesQuery {
  "Additional conditions."
  where: SearchByRootContactSourcesQuery

  "Count conditions."
  count: SearchByScalarInt

  "Alias for `count: {greaterThanOrEqual: 1}`. Will be ignored if `count` used."
  exists: Boolean

  "Alias for `count: {lessThan: 1}`. Will be ignored if `count` used."
  notExists: Boolean! = false
}

"Available operators for `scalar Boolean` (only one operator allowed at a time)."
input SearchByScalarBooleanOrNull {
  "Equal (`=`)."
  equal: Boolean

  "Not Equal (`!=`)."
  notEqual: Boolean

  "Is NULL?"
  isNull: SearchByTypeFlag

  "Is NOT NULL?"
  isNotNull: SearchByTypeFlag
}

"""
Conditions for the relationship (`has()`/`doesntHave()`) for `input UsersQuery`.

See also:
* https://laravel.com/docs/eloquent-relationships#querying-relationship-existence
* https://laravel.com/docs/eloquent-relationships#querying-relationship-absence
"""
input SearchByRelationshipUsersQuery {
  "Additional conditions."
  where: SearchByRootUsersQuery

  "Count conditions."
  count: SearchByScalarInt

  "Alias for `count: {greaterThanOrEqual: 1}`. Will be ignored if `count` used."
  exists: Boolean

  "Alias for `count: {lessThan: 1}`. Will be ignored if `count` used."
  notExists: Boolean! = false
}

"Available conditions for `input ContactsQuery` (only one field allowed at a time)."
input SearchByConditionContactsQuery {
  "Unique primary key."
  id: SearchByScalarUUIDOrNull

  "The status ID of the contact."
  status_id: SearchByScalarUUIDOrNull

  "The status of the contact."
  status: SearchByRelationshipContactStatusesQuery

  "The source ID of the contact."
  source_id: SearchByScalarUUIDOrNull

  "The source of the contact."
  source: SearchByRelationshipContactSourcesQuery

  "The first name of the contact."
  first_name: SearchByScalarStringOrNull

  "The last name of the contact."
  last_name: SearchByScalarStringOrNull

  "The full name of the contact."
  full_name: SearchByScalarStringOrNull

  "The preferred name of the contact."
  preferred: SearchByScalarStringOrNull

  "The description of the contact."
  description: SearchByScalarStringOrNull

  "The email of the contact."
  email: SearchByScalarEmailOrNull

  "The mobile number of the contact."
  mobile: SearchByScalarStringOrNull

  "The phone number of the contact."
  phone: SearchByScalarStringOrNull

  "If the contact is opted out of SMS messages."
  sms_opt_out: SearchByScalarBooleanOrNull

  "If the contact's email bounces."
  email_bounce: SearchByScalarBooleanOrNull

  "The address of the contact."
  address: SearchByScalarStringOrNull

  "The address 2 of the contact."
  address_2: SearchByScalarStringOrNull

  "The address 3 of the contact."
  address_3: SearchByScalarStringOrNull

  "The city of the contact."
  city: SearchByScalarStringOrNull

  "The state of the contact."
  state: SearchByScalarStringOrNull

  "The postal code of the contact."
  postal: SearchByScalarStringOrNull

  "The created date of the contact."
  created_at: SearchByScalarDateTimeOrNull

  "The updated date of the contact."
  updated_at: SearchByScalarDateTimeOrNull

  "The deleted date of the contact."
  deleted_at: SearchByScalarDateTimeOrNull

  "Relationship condition."
  audits: SearchByRelationshipAuditsQuery

  "Relationship condition."
  created_by: SearchByRelationshipUsersQuery

  "Relationship condition."
  assigned_to: SearchByRelationshipUsersQuery
}

"Available conditions for `input ContactsQuery` (only one field allowed at a time)."
input SearchByRootContactsQuery {
  "Field."
  field: SearchByConditionContactsQuery

  "All of the conditions must be true."
  allOf: [SearchByRootContactsQuery!]

  "Any of the conditions must be true."
  anyOf: [SearchByRootContactsQuery!]

  "Not."
  not: SearchByRootContactsQuery
}

"""
Conditions for the relationship (`has()`/`doesntHave()`) for `input ContactsQuery`.

See also:
* https://laravel.com/docs/eloquent-relationships#querying-relationship-existence
* https://laravel.com/docs/eloquent-relationships#querying-relationship-absence
"""
input SearchByRelationshipContactsQuery {
  "Additional conditions."
  where: SearchByRootContactsQuery

  "Count conditions."
  count: SearchByScalarInt

  "Alias for `count: {greaterThanOrEqual: 1}`. Will be ignored if `count` used."
  exists: Boolean

  "Alias for `count: {lessThan: 1}`. Will be ignored if `count` used."
  notExists: Boolean! = false
}

"Available conditions for `input SystemUsersQuery` (only one field allowed at a time)."
input SearchByConditionSystemUsersQuery {
  "Field condition."
  id: SearchByScalarUUIDOrNull

  "Field condition."
  name: SearchByScalarStringOrNull

  "Relationship condition."
  audits: SearchByRelationshipAuditsQuery

  "Field condition."
  created_at: SearchByScalarDateTimeOrNull

  "Field condition."
  updated_at: SearchByScalarDateTimeOrNull

  "Field condition."
  deleted_at: SearchByScalarDateTimeOrNull
}

"Available conditions for `input SystemUsersQuery` (only one field allowed at a time)."
input SearchByRootSystemUsersQuery {
  "Field."
  field: SearchByConditionSystemUsersQuery

  "All of the conditions must be true."
  allOf: [SearchByRootSystemUsersQuery!]

  "Any of the conditions must be true."
  anyOf: [SearchByRootSystemUsersQuery!]

  "Not."
  not: SearchByRootSystemUsersQuery
}

"""
Conditions for the relationship (`has()`/`doesntHave()`) for `input SystemUsersQuery`.

See also:
* https://laravel.com/docs/eloquent-relationships#querying-relationship-existence
* https://laravel.com/docs/eloquent-relationships#querying-relationship-absence
"""
input SearchByRelationshipSystemUsersQuery {
  "Additional conditions."
  where: SearchByRootSystemUsersQuery

  "Count conditions."
  count: SearchByScalarInt

  "Alias for `count: {greaterThanOrEqual: 1}`. Will be ignored if `count` used."
  exists: Boolean

  "Alias for `count: {lessThan: 1}`. Will be ignored if `count` used."
  notExists: Boolean! = false
}

"Available conditions for `input AuditableablesQuery` (only one field allowed at a time)."
input SearchByConditionAuditableablesQuery {
  "Relationship condition."
  contact: SearchByRelationshipContactsQuery

  "Relationship condition."
  user: SearchByRelationshipUsersQuery

  "Relationship condition."
  system_user: SearchByRelationshipSystemUsersQuery
}

"Available conditions for `input AuditableablesQuery` (only one field allowed at a time)."
input SearchByRootAuditableablesQuery {
  "Field."
  field: SearchByConditionAuditableablesQuery

  "All of the conditions must be true."
  allOf: [SearchByRootAuditableablesQuery!]

  "Any of the conditions must be true."
  anyOf: [SearchByRootAuditableablesQuery!]

  "Not."
  not: SearchByRootAuditableablesQuery
}

"""
Conditions for the relationship (`has()`/`doesntHave()`) for `input AuditableablesQuery`.

See also:
* https://laravel.com/docs/eloquent-relationships#querying-relationship-existence
* https://laravel.com/docs/eloquent-relationships#querying-relationship-absence
"""
input SearchByRelationshipAuditableablesQuery {
  "Additional conditions."
  where: SearchByRootAuditableablesQuery

  "Count conditions."
  count: SearchByScalarInt

  "Alias for `count: {greaterThanOrEqual: 1}`. Will be ignored if `count` used."
  exists: Boolean

  "Alias for `count: {lessThan: 1}`. Will be ignored if `count` used."
  notExists: Boolean! = false
}

"Available conditions for `input AuthenticatablesQuery` (only one field allowed at a time)."
input SearchByConditionAuthenticatablesQuery {
  "Relationship condition."
  user: SearchByRelationshipUsersQuery

  "Relationship condition."
  system_user: SearchByRelationshipSystemUsersQuery
}

"Available conditions for `input AuthenticatablesQuery` (only one field allowed at a time)."
input SearchByRootAuthenticatablesQuery {
  "Field."
  field: SearchByConditionAuthenticatablesQuery

  "All of the conditions must be true."
  allOf: [SearchByRootAuthenticatablesQuery!]

  "Any of the conditions must be true."
  anyOf: [SearchByRootAuthenticatablesQuery!]

  "Not."
  not: SearchByRootAuthenticatablesQuery
}

"""
Conditions for the relationship (`has()`/`doesntHave()`) for `input AuthenticatablesQuery`.

See also:
* https://laravel.com/docs/eloquent-relationships#querying-relationship-existence
* https://laravel.com/docs/eloquent-relationships#querying-relationship-absence
"""
input SearchByRelationshipAuthenticatablesQuery {
  "Additional conditions."
  where: SearchByRootAuthenticatablesQuery

  "Count conditions."
  count: SearchByScalarInt

  "Alias for `count: {greaterThanOrEqual: 1}`. Will be ignored if `count` used."
  exists: Boolean

  "Alias for `count: {lessThan: 1}`. Will be ignored if `count` used."
  notExists: Boolean! = false
}

"Available conditions for `input AuditsQuery` (only one field allowed at a time)."
input SearchByConditionAuditsQuery {
  "Field condition."
  id: SearchByScalarUUIDOrNull

  "Field condition."
  change_agent_type: SearchByScalarStringOrNull

  "Field condition."
  change_agent_id: SearchByScalarUUIDOrNull

  "Field condition."
  event: SearchByScalarStringOrNull

  "Field condition."
  old_values: SearchByScalarJSONOrNull

  "Field condition."
  new_values: SearchByScalarJSONOrNull

  "Field condition."
  url: SearchByScalarStringOrNull

  "Field condition."
  ip_address: SearchByScalarStringOrNull

  "Field condition."
  user_agent: SearchByScalarStringOrNull

  "Field condition."
  tags: SearchByScalarStringOrNull

  "Field condition."
  created_at: SearchByScalarDateTimeOrNull

  "Field condition."
  updated_at: SearchByScalarDateTimeOrNull

  "Relationship condition."
  auditable: SearchByRelationshipAuditableablesQuery

  "Relationship condition."
  user: SearchByRelationshipAuthenticatablesQuery
}

"Available conditions for `input AuditsQuery` (only one field allowed at a time)."
input SearchByRootAuditsQuery {
  "Field."
  field: SearchByConditionAuditsQuery

  "All of the conditions must be true."
  allOf: [SearchByRootAuditsQuery!]

  "Any of the conditions must be true."
  anyOf: [SearchByRootAuditsQuery!]

  "Not."
  not: SearchByRootAuditsQuery
}

"""
Conditions for the relationship (`has()`/`doesntHave()`) for `input AuditsQuery`.

See also:
* https://laravel.com/docs/eloquent-relationships#querying-relationship-existence
* https://laravel.com/docs/eloquent-relationships#querying-relationship-absence
"""
input SearchByRelationshipAuditsQuery {
  "Additional conditions."
  where: SearchByRootAuditsQuery

  "Count conditions."
  count: SearchByScalarInt

  "Alias for `count: {greaterThanOrEqual: 1}`. Will be ignored if `count` used."
  exists: Boolean

  "Alias for `count: {lessThan: 1}`. Will be ignored if `count` used."
  notExists: Boolean! = false
}

"Available conditions for `input UsersQuery` (only one field allowed at a time)."
input SearchByConditionUsersQuery {
  "Unique primary key."
  id: SearchByScalarUUIDOrNull

  "Users email address."
  email: SearchByScalarEmailOrNull

  "Relationship condition."
  audits: SearchByRelationshipAuditsQuery
}

"Available conditions for `input UsersQuery` (only one field allowed at a time)."
input SearchByRootUsersQuery {
  "Field."
  field: SearchByConditionUsersQuery

  "All of the conditions must be true."
  allOf: [SearchByRootUsersQuery!]

  "Any of the conditions must be true."
  anyOf: [SearchByRootUsersQuery!]

  "Not."
  not: SearchByRootUsersQuery
}

"Available conditions for `input AlertConcernsQuery` (only one field allowed at a time)."
input SearchByConditionAlertConcernsQuery {
  "Relationship condition."
  contact: SearchByRelationshipContactsQuery
}

"Available conditions for `input AlertConcernsQuery` (only one field allowed at a time)."
input SearchByRootAlertConcernsQuery {
  "Field."
  field: SearchByConditionAlertConcernsQuery

  "All of the conditions must be true."
  allOf: [SearchByRootAlertConcernsQuery!]

  "Any of the conditions must be true."
  anyOf: [SearchByRootAlertConcernsQuery!]

  "Not."
  not: SearchByRootAlertConcernsQuery
}

"""
Conditions for the relationship (`has()`/`doesntHave()`) for `input AlertConcernsQuery`.

See also:
* https://laravel.com/docs/eloquent-relationships#querying-relationship-existence
* https://laravel.com/docs/eloquent-relationships#querying-relationship-absence
"""
input SearchByRelationshipAlertConcernsQuery {
  "Additional conditions."
  where: SearchByRootAlertConcernsQuery

  "Count conditions."
  count: SearchByScalarInt

  "Alias for `count: {greaterThanOrEqual: 1}`. Will be ignored if `count` used."
  exists: Boolean

  "Alias for `count: {lessThan: 1}`. Will be ignored if `count` used."
  notExists: Boolean! = false
}

"Available operators for `scalar EducatableId` (only one operator allowed at a time)."
input SearchByScalarEducatableIdOrNull {
  "Equal (`=`)."
  equal: EducatableId

  "Not Equal (`!=`)."
  notEqual: EducatableId

  "Within a set of values."
  in: [EducatableId!]

  "Outside a set of values."
  notIn: [EducatableId!]

  "Is NULL?"
  isNull: SearchByTypeFlag

  "Is NOT NULL?"
  isNotNull: SearchByTypeFlag
}

"Available operators for `enum EducatableType` (only one operator allowed at a time)."
input SearchByEnumEducatableTypeOrNull {
  "Equal (`=`)."
  equal: EducatableType

  "Not Equal (`!=`)."
  notEqual: EducatableType

  "Within a set of values."
  in: [EducatableType!]

  "Outside a set of values."
  notIn: [EducatableType!]

  "Is NULL?"
  isNull: SearchByTypeFlag

  "Is NOT NULL?"
  isNotNull: SearchByTypeFlag
}

"Available operators for `enum AlertSeverity` (only one operator allowed at a time)."
input SearchByEnumAlertSeverityOrNull {
  "Equal (`=`)."
  equal: AlertSeverity

  "Not Equal (`!=`)."
  notEqual: AlertSeverity

  "Within a set of values."
  in: [AlertSeverity!]

  "Outside a set of values."
  notIn: [AlertSeverity!]

  "Is NULL?"
  isNull: SearchByTypeFlag

  "Is NOT NULL?"
  isNotNull: SearchByTypeFlag
}

"Available operators for `enum AlertStatus` (only one operator allowed at a time)."
input SearchByEnumAlertStatusOrNull {
  "Equal (`=`)."
  equal: AlertStatus

  "Not Equal (`!=`)."
  notEqual: AlertStatus

  "Within a set of values."
  in: [AlertStatus!]

  "Outside a set of values."
  notIn: [AlertStatus!]

  "Is NULL?"
  isNull: SearchByTypeFlag

  "Is NOT NULL?"
  isNotNull: SearchByTypeFlag
}

"Available conditions for `input AlertsQuery` (only one field allowed at a time)."
input SearchByConditionAlertsQuery {
  "Field condition."
  id: SearchByScalarUUIDOrNull

  "Relationship condition."
  concern: SearchByRelationshipAlertConcernsQuery

  "Field condition."
  concern_id: SearchByScalarEducatableIdOrNull

  "Field condition."
  concern_type: SearchByEnumEducatableTypeOrNull

  "Field condition."
  description: SearchByScalarStringOrNull

  "Field condition."
  severity: SearchByEnumAlertSeverityOrNull

  "Field condition."
  status: SearchByEnumAlertStatusOrNull

  "Field condition."
  suggested_intervention: SearchByScalarStringOrNull

  "Field condition."
  created_at: SearchByScalarDateTimeOrNull

  "Field condition."
  updated_at: SearchByScalarDateTimeOrNull

  "Field condition."
  deleted_at: SearchByScalarDateTimeOrNull
}

"Available conditions for `input AlertsQuery` (only one field allowed at a time)."
input SearchByRootAlertsQuery {
  "Field."
  field: SearchByConditionAlertsQuery

  "All of the conditions must be true."
  allOf: [SearchByRootAlertsQuery!]

  "Any of the conditions must be true."
  anyOf: [SearchByRootAlertsQuery!]

  "Not."
  not: SearchByRootAlertsQuery
}

"Sort direction."
enum SortByTypeDirection {
  Asc
  Desc
}

"Sort clause for `input ContactStatusesQuery` (only one field allowed at a time)."
input SortByClauseContactStatusesQuery {
  "The unique primary key of the contact status."
  id: SortByTypeDirection

  "The name of the contact status."
  name: SortByTypeDirection

  "The classification of the contact status."
  classification: SortByTypeDirection

  "The color of the contact status."
  color: SortByTypeDirection

  "The created date of the contact status."
  created_at: SortByTypeDirection

  "The updated date of the contact status."
  updated_at: SortByTypeDirection

  "The deleted date of the contact status."
  deleted_at: SortByTypeDirection

  "The contacts related to this contact status."
  contacts: SortByClauseContactsQuery

  "The audits related to this contact status."
  audits: SortByClauseAuditsQuery
}

"Sort clause for `input ContactSourcesQuery` (only one field allowed at a time)."
input SortByClauseContactSourcesQuery {
  "The unique primary key of the contact source."
  id: SortByTypeDirection

  "The name of the contact source."
  name: SortByTypeDirection

  "The created date of the contact source."
  created_at: SortByTypeDirection

  "The updated date of the contact source."
  updated_at: SortByTypeDirection

  "The deleted date of the contact source."
  deleted_at: SortByTypeDirection

  "The contacts related to this contact source."
  contacts: SortByClauseContactsQuery

  "The audits related to this contact source."
  audits: SortByClauseAuditsQuery
}

"Sort clause for `input UsersQuery` (only one field allowed at a time)."
input SortByClauseUsersQuery {
  "Unique primary key."
  id: SortByTypeDirection

  "Users email address."
  email: SortByTypeDirection

  "Field clause."
  audits: SortByClauseAuditsQuery
}

"Sort clause for `input ContactsQuery` (only one field allowed at a time)."
input SortByClauseContactsQuery {
  "Unique primary key."
  id: SortByTypeDirection

  "The status ID of the contact."
  status_id: SortByTypeDirection

  "The status of the contact."
  status: SortByClauseContactStatusesQuery

  "The source ID of the contact."
  source_id: SortByTypeDirection

  "The source of the contact."
  source: SortByClauseContactSourcesQuery

  "The first name of the contact."
  first_name: SortByTypeDirection

  "The last name of the contact."
  last_name: SortByTypeDirection

  "The full name of the contact."
  full_name: SortByTypeDirection

  "The preferred name of the contact."
  preferred: SortByTypeDirection

  "The description of the contact."
  description: SortByTypeDirection

  "The email of the contact."
  email: SortByTypeDirection

  "The mobile number of the contact."
  mobile: SortByTypeDirection

  "The phone number of the contact."
  phone: SortByTypeDirection

  "If the contact is opted out of SMS messages."
  sms_opt_out: SortByTypeDirection

  "If the contact's email bounces."
  email_bounce: SortByTypeDirection

  "The address of the contact."
  address: SortByTypeDirection

  "The address 2 of the contact."
  address_2: SortByTypeDirection

  "The address 3 of the contact."
  address_3: SortByTypeDirection

  "The city of the contact."
  city: SortByTypeDirection

  "The state of the contact."
  state: SortByTypeDirection

  "The postal code of the contact."
  postal: SortByTypeDirection

  "The created date of the contact."
  created_at: SortByTypeDirection

  "The updated date of the contact."
  updated_at: SortByTypeDirection

  "The deleted date of the contact."
  deleted_at: SortByTypeDirection

  "Field clause."
  audits: SortByClauseAuditsQuery

  "Field clause."
  created_by: SortByClauseUsersQuery

  "Field clause."
  assigned_to: SortByClauseUsersQuery
}

"Sort clause for `input SystemUsersQuery` (only one field allowed at a time)."
input SortByClauseSystemUsersQuery {
  "Field clause."
  id: SortByTypeDirection

  "Field clause."
  name: SortByTypeDirection

  "Field clause."
  audits: SortByClauseAuditsQuery

  "Field clause."
  created_at: SortByTypeDirection

  "Field clause."
  updated_at: SortByTypeDirection

  "Field clause."
  deleted_at: SortByTypeDirection
}

"Sort clause for `input AuditableablesQuery` (only one field allowed at a time)."
input SortByClauseAuditableablesQuery {
  "Field clause."
  contact: SortByClauseContactsQuery

  "Field clause."
  user: SortByClauseUsersQuery

  "Field clause."
  system_user: SortByClauseSystemUsersQuery
}

"Sort clause for `input AuthenticatablesQuery` (only one field allowed at a time)."
input SortByClauseAuthenticatablesQuery {
  "Field clause."
  user: SortByClauseUsersQuery

  "Field clause."
  system_user: SortByClauseSystemUsersQuery
}

"Sort clause for `input AuditsQuery` (only one field allowed at a time)."
input SortByClauseAuditsQuery {
  "Field clause."
  id: SortByTypeDirection

  "Field clause."
  change_agent_type: SortByTypeDirection

  "Field clause."
  change_agent_id: SortByTypeDirection

  "Field clause."
  event: SortByTypeDirection

  "Field clause."
  old_values: SortByTypeDirection

  "Field clause."
  new_values: SortByTypeDirection

  "Field clause."
  url: SortByTypeDirection

  "Field clause."
  ip_address: SortByTypeDirection

  "Field clause."
  user_agent: SortByTypeDirection

  "Field clause."
  tags: SortByTypeDirection

  "Field clause."
  created_at: SortByTypeDirection

  "Field clause."
  updated_at: SortByTypeDirection

  "Field clause."
  auditable: SortByClauseAuditableablesQuery

  "Field clause."
  user: SortByClauseAuthenticatablesQuery
}

"Sort clause for `input AuditsQuery` (only one field allowed at a time)."
input SortByRootAuditsQuery {
  "Field."
  field: SortByClauseAuditsQuery

  "NULLs first"
  nullsFirst: SortByClauseAuditsQuery

  "NULLs last"
  nullsLast: SortByClauseAuditsQuery
}

"Sort clause for `input ContactSourcesQuery` (only one field allowed at a time)."
input SortByRootContactSourcesQuery {
  "Field."
  field: SortByClauseContactSourcesQuery

  "NULLs first"
  nullsFirst: SortByClauseContactSourcesQuery

  "NULLs last"
  nullsLast: SortByClauseContactSourcesQuery
}

"Sort clause for `input ContactStatusesQuery` (only one field allowed at a time)."
input SortByRootContactStatusesQuery {
  "Field."
  field: SortByClauseContactStatusesQuery

  "NULLs first"
  nullsFirst: SortByClauseContactStatusesQuery

  "NULLs last"
  nullsLast: SortByClauseContactStatusesQuery
}

"Sort clause for `input ContactsQuery` (only one field allowed at a time)."
input SortByRootContactsQuery {
  "Field."
  field: SortByClauseContactsQuery

  "NULLs first"
  nullsFirst: SortByClauseContactsQuery

  "NULLs last"
  nullsLast: SortByClauseContactsQuery
}

"Available conditions for `input UserSubscriptionSubscribablesQuery` (only one field allowed at a time)."
input SearchByConditionUserSubscriptionSubscribablesQuery {
  "Relationship condition."
  contact: SearchByRelationshipContactsQuery
}

"Available conditions for `input UserSubscriptionSubscribablesQuery` (only one field allowed at a time)."
input SearchByRootUserSubscriptionSubscribablesQuery {
  "Field."
  field: SearchByConditionUserSubscriptionSubscribablesQuery

  "All of the conditions must be true."
  allOf: [SearchByRootUserSubscriptionSubscribablesQuery!]

  "Any of the conditions must be true."
  anyOf: [SearchByRootUserSubscriptionSubscribablesQuery!]

  "Not."
  not: SearchByRootUserSubscriptionSubscribablesQuery
}

"""
Conditions for the relationship (`has()`/`doesntHave()`) for `input UserSubscriptionSubscribablesQuery`.

See also:
* https://laravel.com/docs/eloquent-relationships#querying-relationship-existence
* https://laravel.com/docs/eloquent-relationships#querying-relationship-absence
"""
input SearchByRelationshipUserSubscriptionSubscribablesQuery {
  "Additional conditions."
  where: SearchByRootUserSubscriptionSubscribablesQuery

  "Count conditions."
  count: SearchByScalarInt

  "Alias for `count: {greaterThanOrEqual: 1}`. Will be ignored if `count` used."
  exists: Boolean

  "Alias for `count: {lessThan: 1}`. Will be ignored if `count` used."
  notExists: Boolean! = false
}

"Available conditions for `input SubscriptionsQuery` (only one field allowed at a time)."
input SearchByConditionSubscriptionsQuery {
  "Field condition."
  id: SearchByScalarUUIDOrNull

  "Relationship condition."
  user: SearchByRelationshipUsersQuery

  "Relationship condition."
  subscribable: SearchByRelationshipUserSubscriptionSubscribablesQuery

  "Field condition."
  subscribable_id: SearchByScalarEducatableIdOrNull

  "Field condition."
  subscribable_type: SearchByEnumEducatableTypeOrNull

  "Field condition."
  created_at: SearchByScalarDateTimeOrNull

  "Field condition."
  updated_at: SearchByScalarDateTimeOrNull
}

"Available conditions for `input SubscriptionsQuery` (only one field allowed at a time)."
input SearchByRootSubscriptionsQuery {
  "Field."
  field: SearchByConditionSubscriptionsQuery

  "All of the conditions must be true."
  allOf: [SearchByRootSubscriptionsQuery!]

  "Any of the conditions must be true."
  anyOf: [SearchByRootSubscriptionsQuery!]

  "Not."
  not: SearchByRootSubscriptionsQuery
}

"Directions for ordering a list of records."
enum SortOrder {
  "Sort records in ascending order."
  ASC

  "Sort records in descending order."
  DESC
}

"Aggregate functions when ordering by a relation without specifying a column."
enum OrderByRelationAggregateFunction {
  "Amount of items."
  COUNT
}

"Aggregate functions when ordering by a relation that may specify a column."
enum OrderByRelationWithColumnAggregateFunction {
  "Average."
  AVG

  "Minimum."
  MIN

  "Maximum."
  MAX

  "Sum."
  SUM

  "Amount of items."
  COUNT
}

"Allows ordering a list of records."
input OrderByClause {
  "The column that is used for ordering."
  column: String!

  "The direction that is used for ordering."
  order: SortOrder!
}

"Specify if you want to include or exclude trashed results from a query."
enum Trashed {
  "Only return trashed results."
  ONLY

  "Return both trashed and non-trashed results."
  WITH

  "Only return non-trashed results."
  WITHOUT
}

"Dynamic WHERE conditions for queries."
input WhereConditions {
  "The column that is used for the condition."
  column: String

  "The operator that is used for the condition."
  operator: SQLOperator = EQ

  "The value that is used for the condition."
  value: Mixed

  "A set of conditions that requires all conditions to match."
  AND: [WhereConditions!]

  "A set of conditions that requires at least one condition to match."
  OR: [WhereConditions!]

  "Check whether a relation exists. Extra conditions or a minimum amount can be applied."
  HAS: WhereConditionsRelation
}

"Dynamic HAS conditions for WHERE condition queries."
input WhereConditionsRelation {
  "The relation that is checked."
  relation: String!

  "The comparison operator to test against the amount."
  operator: SQLOperator = GTE

  "The amount to test."
  amount: Int = 1

  "Additional condition logic."
  condition: WhereConditions
}

"The available SQL operators that are used to filter query results."
enum SQLOperator {
  "Equal operator (`=`)"
  EQ

  "Not equal operator (`!=`)"
  NEQ

  "Greater than operator (`>`)"
  GT

  "Greater than or equal operator (`>=`)"
  GTE

  "Less than operator (`<`)"
  LT

  "Less than or equal operator (`<=`)"
  LTE

  "Simple pattern matching (`LIKE`)"
  LIKE

  "Negation of simple pattern matching (`NOT LIKE`)"
  NOT_LIKE

  "Whether a value is within a set of values (`IN`)"
  IN

  "Whether a value is not within a set of values (`NOT IN`)"
  NOT_IN

  "Whether a value is within a range of values (`BETWEEN`)"
  BETWEEN

  "Whether a value is not within a range of values (`NOT BETWEEN`)"
  NOT_BETWEEN

  "Whether a value is null (`IS NULL`)"
  IS_NULL

  "Whether a value is not null (`IS NOT NULL`)"
  IS_NOT_NULL
}

"""
Loose type that allows any value. Be careful when passing in large `Int` or `Float` literals,
as they may not be parsed correctly on the server side. Use `String` literals if you are
dealing with really large numbers to be on the safe side.
"""
scalar Mixed

"A GraphQL Schema defines the capabilities of a GraphQL server. It exposes all available types and directives on the server, as well as the entry points for query, mutation, and subscription operations."
type __Schema {
  "A list of all types supported by this server."
  types: [__Type!]!

  "The type that query operations will be rooted at."
  queryType: __Type!

  "If this server supports mutation, the type that mutation operations will be rooted at."
  mutationType: __Type

  "If this server support subscription, the type that subscription operations will be rooted at."
  subscriptionType: __Type

  "A list of all directives supported by this server."
  directives: [__Directive!]!
}

"""
The fundamental unit of any GraphQL Schema is the type. There are many kinds of types in GraphQL as represented by the `__TypeKind` enum.

Depending on the kind of a type, certain fields describe information about that type. Scalar types provide no information beyond a name and description, while Enum types provide their values. Object and Interface types provide the fields they describe. Abstract types, Union and Interface, provide the Object types possible at runtime. List and NonNull types compose other types.
"""
type __Type {
  kind: __TypeKind!
  name: String
  description: String
  fields(includeDeprecated: Boolean = false): [__Field!]
  interfaces: [__Type!]
  possibleTypes: [__Type!]
  enumValues(includeDeprecated: Boolean = false): [__EnumValue!]
  inputFields(includeDeprecated: Boolean = false): [__InputValue!]
  ofType: __Type
}

"An enum describing what kind of type a given `__Type` is."
enum __TypeKind {
  "Indicates this type is a scalar."
  SCALAR

  "Indicates this type is an object. `fields` and `interfaces` are valid fields."
  OBJECT

  "Indicates this type is an interface. `fields`, `interfaces`, and `possibleTypes` are valid fields."
  INTERFACE

  "Indicates this type is a union. `possibleTypes` is a valid field."
  UNION

  "Indicates this type is an enum. `enumValues` is a valid field."
  ENUM

  "Indicates this type is an input object. `inputFields` is a valid field."
  INPUT_OBJECT

  "Indicates this type is a list. `ofType` is a valid field."
  LIST

  "Indicates this type is a non-null. `ofType` is a valid field."
  NON_NULL
}

"Object and Interface types are described by a list of Fields, each of which has a name, potentially a list of arguments, and a return type."
type __Field {
  name: String!
  description: String
  args(includeDeprecated: Boolean = false): [__InputValue!]!
  type: __Type!
  isDeprecated: Boolean!
  deprecationReason: String
}

"Arguments provided to Fields or Directives and the input fields of an InputObject are represented as Input Values which describe their type and optionally a default value."
type __InputValue {
  name: String!
  description: String
  type: __Type!

  "A GraphQL-formatted string representing the default value for this input value."
  defaultValue: String

  isDeprecated: Boolean!
  deprecationReason: String
}

"One possible value for a given Enum. Enum values are unique values, not a placeholder for a string or numeric value. However an Enum value is returned in a JSON response as a string."
type __EnumValue {
  name: String!
  description: String
  isDeprecated: Boolean!
  deprecationReason: String
}

"""
A Directive provides a way to describe alternate runtime execution and type validation behavior in a GraphQL document.

In some cases, you need to provide options to alter GraphQL's execution behavior in ways field arguments will not suffice, such as conditionally including or skipping a field. Directives provide this by describing additional information to the executor.
"""
type __Directive {
  name: String!
  description: String
  isRepeatable: Boolean!
  locations: [__DirectiveLocation!]!
  args: [__InputValue!]!
}

"A Directive can be adjacent to many parts of the GraphQL language, a __DirectiveLocation describes one such possible adjacencies."
enum __DirectiveLocation {
  "Location adjacent to a query operation."
  QUERY

  "Location adjacent to a mutation operation."
  MUTATION

  "Location adjacent to a subscription operation."
  SUBSCRIPTION

  "Location adjacent to a field."
  FIELD

  "Location adjacent to a fragment definition."
  FRAGMENT_DEFINITION

  "Location adjacent to a fragment spread."
  FRAGMENT_SPREAD

  "Location adjacent to an inline fragment."
  INLINE_FRAGMENT

  "Location adjacent to a variable definition."
  VARIABLE_DEFINITION

  "Location adjacent to a schema definition."
  SCHEMA

  "Location adjacent to a scalar definition."
  SCALAR

  "Location adjacent to an object type definition."
  OBJECT

  "Location adjacent to a field definition."
  FIELD_DEFINITION

  "Location adjacent to an argument definition."
  ARGUMENT_DEFINITION

  "Location adjacent to an interface definition."
  INTERFACE

  "Location adjacent to a union definition."
  UNION

  "Location adjacent to an enum definition."
  ENUM

  "Location adjacent to an enum value definition."
  ENUM_VALUE

  "Location adjacent to an input object type definition."
  INPUT_OBJECT

  "Location adjacent to an input object field definition."
  INPUT_FIELD_DEFINITION
}
